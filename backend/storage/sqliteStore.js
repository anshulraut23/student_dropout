import Database from 'better-sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create database file in the storage directory
const dbPath = path.join(__dirname, 'education_assistant.db');
const db = new Database(dbPath);

// Enable foreign keys
db.pragma('foreign_keys = ON');

// Initialize database tables
function initializeDatabase() {
  // Schools table
  db.exec(`
    CREATE TABLE IF NOT EXISTS schools (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      address TEXT NOT NULL,
      city TEXT NOT NULL,
      state TEXT NOT NULL,
      phone TEXT NOT NULL,
      adminId TEXT,
      createdAt TEXT NOT NULL
    )
  `);

  // Users table
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY,
      email TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      fullName TEXT NOT NULL,
      role TEXT NOT NULL,
      schoolId TEXT NOT NULL,
      status TEXT NOT NULL,
      assignedClasses TEXT,
      createdAt TEXT NOT NULL,
      FOREIGN KEY (schoolId) REFERENCES schools(id)
    )
  `);

  // Teacher requests table
  db.exec(`
    CREATE TABLE IF NOT EXISTS teacher_requests (
      teacherId TEXT PRIMARY KEY,
      schoolId TEXT NOT NULL,
      status TEXT NOT NULL,
      requestedAt TEXT NOT NULL,
      processedAt TEXT,
      FOREIGN KEY (teacherId) REFERENCES users(id),
      FOREIGN KEY (schoolId) REFERENCES schools(id)
    )
  `);

  // Classes table
  db.exec(`
    CREATE TABLE IF NOT EXISTS classes (
      id TEXT PRIMARY KEY,
      schoolId TEXT NOT NULL,
      name TEXT NOT NULL,
      grade TEXT NOT NULL,
      section TEXT,
      academicYear TEXT NOT NULL,
      teacherId TEXT,
      attendanceMode TEXT NOT NULL,
      status TEXT NOT NULL,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (schoolId) REFERENCES schools(id),
      FOREIGN KEY (teacherId) REFERENCES users(id)
    )
  `);

  // Subjects table
  db.exec(`
    CREATE TABLE IF NOT EXISTS subjects (
      id TEXT PRIMARY KEY,
      schoolId TEXT NOT NULL,
      classId TEXT NOT NULL,
      name TEXT NOT NULL,
      teacherId TEXT,
      status TEXT NOT NULL,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (schoolId) REFERENCES schools(id),
      FOREIGN KEY (classId) REFERENCES classes(id),
      FOREIGN KEY (teacherId) REFERENCES users(id)
    )
  `);

  // Students table
  db.exec(`
    CREATE TABLE IF NOT EXISTS students (
      id TEXT PRIMARY KEY,
      classId TEXT NOT NULL,
      name TEXT NOT NULL,
      enrollmentNo TEXT,
      dateOfBirth TEXT,
      gender TEXT,
      contact TEXT,
      email TEXT,
      address TEXT,
      parentName TEXT,
      parentContact TEXT,
      parentEmail TEXT,
      status TEXT NOT NULL,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (classId) REFERENCES classes(id)
    )
  `);

  // Attendance table
  db.exec(`
    CREATE TABLE IF NOT EXISTS attendance (
      id TEXT PRIMARY KEY,
      studentId TEXT NOT NULL,
      classId TEXT NOT NULL,
      subjectId TEXT,
      date TEXT NOT NULL,
      status TEXT NOT NULL,
      markedBy TEXT NOT NULL,
      markedAt TEXT NOT NULL,
      notes TEXT,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (studentId) REFERENCES students(id),
      FOREIGN KEY (classId) REFERENCES classes(id),
      FOREIGN KEY (subjectId) REFERENCES subjects(id),
      FOREIGN KEY (markedBy) REFERENCES users(id)
    )
  `);

  // Exams table
  db.exec(`
    CREATE TABLE IF NOT EXISTS exams (
      id TEXT PRIMARY KEY,
      schoolId TEXT NOT NULL,
      periodId TEXT,
      templateId TEXT,
      name TEXT NOT NULL,
      type TEXT NOT NULL,
      classId TEXT NOT NULL,
      subjectId TEXT NOT NULL,
      totalMarks INTEGER NOT NULL,
      passingMarks INTEGER NOT NULL,
      weightage REAL DEFAULT 1.0,
      examDate TEXT NOT NULL,
      duration INTEGER,
      instructions TEXT,
      syllabusTopics TEXT,
      createdBy TEXT NOT NULL,
      status TEXT DEFAULT 'scheduled',
      isAutoGenerated INTEGER DEFAULT 0,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (schoolId) REFERENCES schools(id),
      FOREIGN KEY (periodId) REFERENCES exam_periods(id),
      FOREIGN KEY (templateId) REFERENCES exam_templates(id),
      FOREIGN KEY (classId) REFERENCES classes(id),
      FOREIGN KEY (subjectId) REFERENCES subjects(id),
      FOREIGN KEY (createdBy) REFERENCES users(id)
    )
  `);

  // Create indexes for exams
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_exams_school ON exams(schoolId);
    CREATE INDEX IF NOT EXISTS idx_exams_period ON exams(periodId);
    CREATE INDEX IF NOT EXISTS idx_exams_template ON exams(templateId);
    CREATE INDEX IF NOT EXISTS idx_exams_class ON exams(classId);
    CREATE INDEX IF NOT EXISTS idx_exams_subject ON exams(subjectId);
    CREATE INDEX IF NOT EXISTS idx_exams_date ON exams(examDate);
    CREATE INDEX IF NOT EXISTS idx_exams_status ON exams(status);
    CREATE INDEX IF NOT EXISTS idx_exams_auto ON exams(isAutoGenerated);
    CREATE UNIQUE INDEX IF NOT EXISTS idx_exams_period_class_subject ON exams(periodId, classId, subjectId) WHERE periodId IS NOT NULL;
  `);

  // Marks table
  db.exec(`
    CREATE TABLE IF NOT EXISTS marks (
      id TEXT PRIMARY KEY,
      examId TEXT NOT NULL,
      studentId TEXT NOT NULL,
      marksObtained REAL NOT NULL,
      grade TEXT,
      gradePoint REAL,
      percentage REAL,
      status TEXT DEFAULT 'present',
      remarks TEXT,
      enteredBy TEXT NOT NULL,
      enteredAt TEXT NOT NULL,
      updatedBy TEXT,
      updatedAt TEXT,
      verifiedBy TEXT,
      verifiedAt TEXT,
      FOREIGN KEY (examId) REFERENCES exams(id),
      FOREIGN KEY (studentId) REFERENCES students(id),
      FOREIGN KEY (enteredBy) REFERENCES users(id),
      UNIQUE(examId, studentId)
    )
  `);

  // Create indexes for marks
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_marks_exam ON marks(examId);
    CREATE INDEX IF NOT EXISTS idx_marks_student ON marks(studentId);
    CREATE INDEX IF NOT EXISTS idx_marks_grade ON marks(grade);
  `);

  // Grade configuration table
  db.exec(`
    CREATE TABLE IF NOT EXISTS grade_config (
      id TEXT PRIMARY KEY,
      schoolId TEXT NOT NULL,
      name TEXT NOT NULL,
      isDefault INTEGER DEFAULT 0,
      grades TEXT NOT NULL,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (schoolId) REFERENCES schools(id)
    )
  `);

  // Exam Templates table (NEW - for standardized exams)
  db.exec(`
    CREATE TABLE IF NOT EXISTS exam_templates (
      id TEXT PRIMARY KEY,
      schoolId TEXT NOT NULL,
      name TEXT NOT NULL,
      type TEXT NOT NULL,
      description TEXT,
      totalMarks INTEGER NOT NULL,
      passingMarks INTEGER NOT NULL,
      weightage REAL NOT NULL,
      isActive INTEGER DEFAULT 1,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (schoolId) REFERENCES schools(id)
    )
  `);

  // Create indexes for exam_templates
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_exam_templates_school ON exam_templates(schoolId);
    CREATE INDEX IF NOT EXISTS idx_exam_templates_active ON exam_templates(isActive);
  `);

  // Exam Periods table (NEW - for scheduling exams)
  db.exec(`
    CREATE TABLE IF NOT EXISTS exam_periods (
      id TEXT PRIMARY KEY,
      schoolId TEXT NOT NULL,
      templateId TEXT NOT NULL,
      academicYear TEXT NOT NULL,
      startDate TEXT NOT NULL,
      endDate TEXT NOT NULL,
      status TEXT DEFAULT 'scheduled',
      createdBy TEXT NOT NULL,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (schoolId) REFERENCES schools(id),
      FOREIGN KEY (templateId) REFERENCES exam_templates(id),
      FOREIGN KEY (createdBy) REFERENCES users(id)
    )
  `);

  // Create indexes for exam_periods
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_exam_periods_school ON exam_periods(schoolId);
    CREATE INDEX IF NOT EXISTS idx_exam_periods_template ON exam_periods(templateId);
    CREATE INDEX IF NOT EXISTS idx_exam_periods_year ON exam_periods(academicYear);
    CREATE INDEX IF NOT EXISTS idx_exam_periods_status ON exam_periods(status);
    CREATE INDEX IF NOT EXISTS idx_exam_periods_dates ON exam_periods(startDate, endDate);
  `);

  // Faculty Invites table (NEW - for inter-teacher chat connectivity)
  db.exec(`
    CREATE TABLE IF NOT EXISTS faculty_invites (
      id TEXT PRIMARY KEY,
      senderId TEXT NOT NULL,
      recipientId TEXT NOT NULL,
      schoolId TEXT NOT NULL,
      status TEXT NOT NULL,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (senderId) REFERENCES users(id),
      FOREIGN KEY (recipientId) REFERENCES users(id),
      FOREIGN KEY (schoolId) REFERENCES schools(id)
    )
  `);

  // Create indexes for faculty_invites
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_faculty_invites_sender ON faculty_invites(senderId);
    CREATE INDEX IF NOT EXISTS idx_faculty_invites_recipient ON faculty_invites(recipientId);
    CREATE INDEX IF NOT EXISTS idx_faculty_invites_school ON faculty_invites(schoolId);
    CREATE INDEX IF NOT EXISTS idx_faculty_invites_status ON faculty_invites(status);
  `);

  console.log('âœ… SQLite database initialized at:', dbPath);
}

// Initialize on import
initializeDatabase();

class SQLiteStore {
  // School operations
  getSchools() {
    const stmt = db.prepare('SELECT * FROM schools');
    return stmt.all();
  }

  addSchool(school) {
    const stmt = db.prepare(`
      INSERT INTO schools (id, name, address, city, state, phone, adminId, createdAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(school.id, school.name, school.address, school.city, school.state, school.phone, school.adminId, school.createdAt);
    return school;
  }

  getSchoolById(schoolId) {
    const stmt = db.prepare('SELECT * FROM schools WHERE id = ?');
    return stmt.get(schoolId);
  }

  updateSchool(schoolId, updates) {
    const school = this.getSchoolById(schoolId);
    if (!school) return null;

    const updatedSchool = { ...school, ...updates };
    
    const stmt = db.prepare(`
      UPDATE schools 
      SET name = ?, address = ?, city = ?, state = ?, phone = ?, adminId = ?
      WHERE id = ?
    `);
    stmt.run(
      updatedSchool.name,
      updatedSchool.address,
      updatedSchool.city,
      updatedSchool.state,
      updatedSchool.phone,
      updatedSchool.adminId,
      schoolId
    );
    
    return this.getSchoolById(schoolId);
  }

  // User operations
  getUsers() {
    const stmt = db.prepare('SELECT * FROM users');
    const users = stmt.all();
    return users.map(user => ({
      ...user,
      assignedClasses: user.assignedClasses ? JSON.parse(user.assignedClasses) : []
    }));
  }

  addUser(user) {
    const stmt = db.prepare(`
      INSERT INTO users (id, email, password, fullName, role, schoolId, status, assignedClasses, createdAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      user.id, 
      user.email, 
      user.password, 
      user.fullName, 
      user.role, 
      user.schoolId, 
      user.status,
      JSON.stringify(user.assignedClasses || []),
      user.createdAt
    );
    return user;
  }

  getUserByEmail(email) {
    const stmt = db.prepare('SELECT * FROM users WHERE email = ?');
    const user = stmt.get(email);
    if (user) {
      user.assignedClasses = user.assignedClasses ? JSON.parse(user.assignedClasses) : [];
    }
    return user;
  }

  getUserById(userId) {
    const stmt = db.prepare('SELECT * FROM users WHERE id = ?');
    const user = stmt.get(userId);
    if (user) {
      user.assignedClasses = user.assignedClasses ? JSON.parse(user.assignedClasses) : [];
    }
    return user;
  }

  updateUser(userId, updates) {
    const user = this.getUserById(userId);
    if (!user) return null;

    const updatedUser = { ...user, ...updates };
    
    const stmt = db.prepare(`
      UPDATE users 
      SET email = ?, password = ?, fullName = ?, role = ?, schoolId = ?, status = ?, assignedClasses = ?,
          phone = ?, designation = ?, address = ?, city = ?, state = ?, pincode = ?, profilePicture = ?, updatedAt = ?
      WHERE id = ?
    `);
    stmt.run(
      updatedUser.email,
      updatedUser.password,
      updatedUser.fullName,
      updatedUser.role,
      updatedUser.schoolId,
      updatedUser.status,
      JSON.stringify(updatedUser.assignedClasses || []),
      updatedUser.phone || null,
      updatedUser.designation || null,
      updatedUser.address || null,
      updatedUser.city || null,
      updatedUser.state || null,
      updatedUser.pincode || null,
      updatedUser.profilePicture || null,
      updatedUser.updatedAt || new Date().toISOString(),
      userId
    );
    
    return this.getUserById(userId);
  }

  // Teacher request operations
  getRequests() {
    const stmt = db.prepare('SELECT * FROM teacher_requests');
    return stmt.all();
  }

  addRequest(request) {
    const stmt = db.prepare(`
      INSERT INTO teacher_requests (teacherId, schoolId, status, requestedAt, processedAt)
      VALUES (?, ?, ?, ?, ?)
    `);
    stmt.run(request.teacherId, request.schoolId, request.status, request.requestedAt, request.processedAt);
    return request;
  }

  getRequestsBySchool(schoolId) {
    const stmt = db.prepare('SELECT * FROM teacher_requests WHERE schoolId = ? AND status = ?');
    return stmt.all(schoolId, 'pending');
  }

  updateRequest(teacherId, updates) {
    const stmt = db.prepare(`
      UPDATE teacher_requests 
      SET status = ?, processedAt = ?
      WHERE teacherId = ?
    `);
    stmt.run(updates.status, updates.processedAt, teacherId);
    
    const getStmt = db.prepare('SELECT * FROM teacher_requests WHERE teacherId = ?');
    return getStmt.get(teacherId);
  }

  // Class operations
  getClasses() {
    const stmt = db.prepare('SELECT * FROM classes');
    return stmt.all();
  }

  addClass(classData) {
    const stmt = db.prepare(`
      INSERT INTO classes (id, schoolId, name, grade, section, academicYear, teacherId, attendanceMode, status, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      classData.id,
      classData.schoolId,
      classData.name,
      classData.grade,
      classData.section,
      classData.academicYear,
      classData.teacherId,
      classData.attendanceMode,
      classData.status,
      classData.createdAt,
      classData.updatedAt
    );
    return classData;
  }

  getClassById(classId) {
    const stmt = db.prepare('SELECT * FROM classes WHERE id = ?');
    return stmt.get(classId);
  }

  getClassesBySchool(schoolId) {
    const stmt = db.prepare('SELECT * FROM classes WHERE schoolId = ?');
    return stmt.all(schoolId);
  }

  updateClass(classId, updates) {
    const classData = this.getClassById(classId);
    if (!classData) return null;

    const updatedClass = { ...classData, ...updates };
    
    const stmt = db.prepare(`
      UPDATE classes 
      SET name = ?, grade = ?, section = ?, academicYear = ?, teacherId = ?, attendanceMode = ?, status = ?, updatedAt = ?
      WHERE id = ?
    `);
    stmt.run(
      updatedClass.name,
      updatedClass.grade,
      updatedClass.section,
      updatedClass.academicYear,
      updatedClass.teacherId,
      updatedClass.attendanceMode,
      updatedClass.status,
      updatedClass.updatedAt,
      classId
    );
    
    return this.getClassById(classId);
  }

  deleteClass(classId) {
    const stmt = db.prepare('DELETE FROM classes WHERE id = ?');
    const result = stmt.run(classId);
    return result.changes > 0;
  }

  // Subject operations
  getSubjects() {
    const stmt = db.prepare('SELECT * FROM subjects');
    return stmt.all();
  }

  addSubject(subjectData) {
    const stmt = db.prepare(`
      INSERT INTO subjects (id, schoolId, classId, name, teacherId, status, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      subjectData.id,
      subjectData.schoolId,
      subjectData.classId,
      subjectData.name,
      subjectData.teacherId,
      subjectData.status,
      subjectData.createdAt,
      subjectData.updatedAt
    );
    return subjectData;
  }

  getSubjectById(subjectId) {
    const stmt = db.prepare('SELECT * FROM subjects WHERE id = ?');
    return stmt.get(subjectId);
  }

  getSubjectsByClass(classId) {
    const stmt = db.prepare('SELECT * FROM subjects WHERE classId = ?');
    return stmt.all(classId);
  }

  getSubjectsBySchool(schoolId) {
    const stmt = db.prepare('SELECT * FROM subjects WHERE schoolId = ?');
    return stmt.all(schoolId);
  }

  updateSubject(subjectId, updates) {
    const subject = this.getSubjectById(subjectId);
    if (!subject) return null;

    const updatedSubject = { ...subject, ...updates };
    
    const stmt = db.prepare(`
      UPDATE subjects 
      SET name = ?, teacherId = ?, status = ?, updatedAt = ?
      WHERE id = ?
    `);
    stmt.run(
      updatedSubject.name,
      updatedSubject.teacherId,
      updatedSubject.status,
      updatedSubject.updatedAt,
      subjectId
    );
    
    return this.getSubjectById(subjectId);
  }

  deleteSubject(subjectId) {
    const stmt = db.prepare('DELETE FROM subjects WHERE id = ?');
    const result = stmt.run(subjectId);
    return result.changes > 0;
  }

  // Student operations
  getStudents() {
    const stmt = db.prepare('SELECT * FROM students');
    return stmt.all();
  }

  addStudent(studentData) {
    const stmt = db.prepare(`
      INSERT INTO students (id, classId, name, enrollmentNo, dateOfBirth, gender, contact, email, address, parentName, parentContact, parentEmail, status, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      studentData.id,
      studentData.classId,
      studentData.name,
      studentData.enrollmentNo,
      studentData.dateOfBirth,
      studentData.gender,
      studentData.contact,
      studentData.email,
      studentData.address,
      studentData.parentName,
      studentData.parentContact,
      studentData.parentEmail,
      studentData.status,
      studentData.createdAt,
      studentData.updatedAt
    );
    return studentData;
  }

  getStudentById(studentId) {
    const stmt = db.prepare('SELECT * FROM students WHERE id = ?');
    return stmt.get(studentId);
  }

  getStudentsByClass(classId) {
    const stmt = db.prepare('SELECT * FROM students WHERE classId = ?');
    return stmt.all(classId);
  }

  updateStudent(studentId, updates) {
    const student = this.getStudentById(studentId);
    if (!student) return null;

    const updatedStudent = { ...student, ...updates };
    
    const stmt = db.prepare(`
      UPDATE students 
      SET classId = ?, name = ?, enrollmentNo = ?, dateOfBirth = ?, gender = ?, contact = ?, email = ?, address = ?, parentName = ?, parentContact = ?, parentEmail = ?, status = ?, updatedAt = ?
      WHERE id = ?
    `);
    stmt.run(
      updatedStudent.classId,
      updatedStudent.name,
      updatedStudent.enrollmentNo,
      updatedStudent.dateOfBirth,
      updatedStudent.gender,
      updatedStudent.contact,
      updatedStudent.email,
      updatedStudent.address,
      updatedStudent.parentName,
      updatedStudent.parentContact,
      updatedStudent.parentEmail,
      updatedStudent.status,
      updatedStudent.updatedAt,
      studentId
    );
    
    return this.getStudentById(studentId);
  }

  deleteStudent(studentId) {
    const stmt = db.prepare('DELETE FROM students WHERE id = ?');
    const result = stmt.run(studentId);
    return result.changes > 0;
  }

  // Attendance operations
  getAttendance() {
    const stmt = db.prepare('SELECT * FROM attendance');
    return stmt.all();
  }

  addAttendance(attendanceData) {
    const stmt = db.prepare(`
      INSERT INTO attendance (id, studentId, classId, subjectId, date, status, markedBy, markedAt, notes, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      attendanceData.id,
      attendanceData.studentId,
      attendanceData.classId,
      attendanceData.subjectId,
      attendanceData.date,
      attendanceData.status,
      attendanceData.markedBy,
      attendanceData.markedAt,
      attendanceData.notes,
      attendanceData.createdAt,
      attendanceData.updatedAt
    );
    return attendanceData;
  }

  getAttendanceById(attendanceId) {
    const stmt = db.prepare('SELECT * FROM attendance WHERE id = ?');
    return stmt.get(attendanceId);
  }

  getAttendanceByStudent(studentId, filters = {}) {
    let query = 'SELECT * FROM attendance WHERE studentId = ?';
    const params = [studentId];
    
    if (filters.startDate) {
      query += ' AND date >= ?';
      params.push(filters.startDate);
    }
    if (filters.endDate) {
      query += ' AND date <= ?';
      params.push(filters.endDate);
    }
    if (filters.subjectId) {
      query += ' AND subjectId = ?';
      params.push(filters.subjectId);
    }
    if (filters.classId) {
      query += ' AND classId = ?';
      params.push(filters.classId);
    }
    
    const stmt = db.prepare(query);
    return stmt.all(...params);
  }

  getAttendanceByClass(classId, filters = {}) {
    let query = 'SELECT * FROM attendance WHERE classId = ?';
    const params = [classId];
    
    if (filters.date) {
      query += ' AND date = ?';
      params.push(filters.date);
    }
    if (filters.startDate) {
      query += ' AND date >= ?';
      params.push(filters.startDate);
    }
    if (filters.endDate) {
      query += ' AND date <= ?';
      params.push(filters.endDate);
    }
    if (filters.subjectId) {
      query += ' AND subjectId = ?';
      params.push(filters.subjectId);
    }
    if (filters.status) {
      query += ' AND status = ?';
      params.push(filters.status);
    }
    
    const stmt = db.prepare(query);
    return stmt.all(...params);
  }

  getAttendanceByDate(date, classId, subjectId = null) {
    let query = 'SELECT * FROM attendance WHERE date = ? AND classId = ?';
    const params = [date, classId];
    
    if (subjectId) {
      query += ' AND subjectId = ?';
      params.push(subjectId);
    } else {
      query += ' AND subjectId IS NULL';
    }
    
    const stmt = db.prepare(query);
    return stmt.all(...params);
  }

  updateAttendance(attendanceId, updates) {
    const attendance = this.getAttendanceById(attendanceId);
    if (!attendance) return null;

    const updatedAttendance = { ...attendance, ...updates };
    
    const stmt = db.prepare(`
      UPDATE attendance 
      SET studentId = ?, classId = ?, subjectId = ?, date = ?, status = ?, markedBy = ?, markedAt = ?, notes = ?, updatedAt = ?
      WHERE id = ?
    `);
    stmt.run(
      updatedAttendance.studentId,
      updatedAttendance.classId,
      updatedAttendance.subjectId,
      updatedAttendance.date,
      updatedAttendance.status,
      updatedAttendance.markedBy,
      updatedAttendance.markedAt,
      updatedAttendance.notes,
      updatedAttendance.updatedAt,
      attendanceId
    );
    
    return this.getAttendanceById(attendanceId);
  }

  deleteAttendance(attendanceId) {
    const stmt = db.prepare('DELETE FROM attendance WHERE id = ?');
    const result = stmt.run(attendanceId);
    return result.changes > 0;
  }

  // ==================== EXAM METHODS ====================

  addExam(exam) {
    const stmt = db.prepare(`
      INSERT INTO exams (
        id, schoolId, name, type, classId, subjectId, totalMarks, passingMarks,
        weightage, examDate, duration, instructions, syllabusTopics, createdBy,
        status, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(
      exam.id,
      exam.schoolId,
      exam.name,
      exam.type,
      exam.classId,
      exam.subjectId,
      exam.totalMarks,
      exam.passingMarks,
      exam.weightage || 1.0,
      exam.examDate,
      exam.duration || null,
      exam.instructions || null,
      exam.syllabusTopics || null,
      exam.createdBy,
      exam.status || 'scheduled',
      exam.createdAt,
      exam.updatedAt
    );
    
    return exam;
  }

  getExams() {
    const stmt = db.prepare('SELECT * FROM exams ORDER BY examDate DESC');
    return stmt.all();
  }

  getExamById(examId) {
    const stmt = db.prepare('SELECT * FROM exams WHERE id = ?');
    return stmt.get(examId);
  }

  getExamsByClass(classId) {
    const stmt = db.prepare('SELECT * FROM exams WHERE classId = ? ORDER BY examDate DESC');
    return stmt.all(classId);
  }

  getExamsBySubject(subjectId) {
    const stmt = db.prepare('SELECT * FROM exams WHERE subjectId = ? ORDER BY examDate DESC');
    return stmt.all(subjectId);
  }

  updateExam(examId, updates) {
    const exam = this.getExamById(examId);
    if (!exam) return null;

    const updatedExam = { ...exam, ...updates, updatedAt: new Date().toISOString() };
    
    const stmt = db.prepare(`
      UPDATE exams SET
        name = ?, type = ?, classId = ?, subjectId = ?, totalMarks = ?,
        passingMarks = ?, weightage = ?, examDate = ?, duration = ?,
        instructions = ?, syllabusTopics = ?, status = ?, updatedAt = ?
      WHERE id = ?
    `);
    
    stmt.run(
      updatedExam.name,
      updatedExam.type,
      updatedExam.classId,
      updatedExam.subjectId,
      updatedExam.totalMarks,
      updatedExam.passingMarks,
      updatedExam.weightage,
      updatedExam.examDate,
      updatedExam.duration,
      updatedExam.instructions,
      updatedExam.syllabusTopics,
      updatedExam.status,
      updatedExam.updatedAt,
      examId
    );
    
    return this.getExamById(examId);
  }

  deleteExam(examId) {
    const stmt = db.prepare('DELETE FROM exams WHERE id = ?');
    const result = stmt.run(examId);
    return result.changes > 0;
  }

  // ==================== MARKS METHODS ====================

  addMarks(marks) {
    const stmt = db.prepare(`
      INSERT INTO marks (
        id, examId, studentId, marksObtained, grade, gradePoint, percentage,
        status, remarks, enteredBy, enteredAt, updatedBy, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(
      marks.id,
      marks.examId,
      marks.studentId,
      marks.marksObtained,
      marks.grade || null,
      marks.gradePoint || null,
      marks.percentage || null,
      marks.status || 'present',
      marks.remarks || null,
      marks.enteredBy,
      marks.enteredAt,
      marks.updatedBy || null,
      marks.updatedAt || null
    );
    
    return marks;
  }

  getMarks() {
    const stmt = db.prepare('SELECT * FROM marks');
    return stmt.all();
  }

  getMarksById(marksId) {
    const stmt = db.prepare('SELECT * FROM marks WHERE id = ?');
    return stmt.get(marksId);
  }

  getMarksByExam(examId) {
    const stmt = db.prepare('SELECT * FROM marks WHERE examId = ?');
    return stmt.all(examId);
  }

  getMarksByStudent(studentId) {
    const stmt = db.prepare('SELECT * FROM marks WHERE studentId = ? ORDER BY enteredAt DESC');
    return stmt.all(studentId);
  }

  getMarksByExamAndStudent(examId, studentId) {
    const stmt = db.prepare('SELECT * FROM marks WHERE examId = ? AND studentId = ?');
    return stmt.get(examId, studentId);
  }

  updateMarks(marksId, updates) {
    const marks = this.getMarksById(marksId);
    if (!marks) return null;

    const updatedMarks = { ...marks, ...updates, updatedAt: new Date().toISOString() };
    
    const stmt = db.prepare(`
      UPDATE marks SET
        marksObtained = ?, grade = ?, gradePoint = ?, percentage = ?,
        status = ?, remarks = ?, updatedBy = ?, updatedAt = ?
      WHERE id = ?
    `);
    
    stmt.run(
      updatedMarks.marksObtained,
      updatedMarks.grade,
      updatedMarks.gradePoint,
      updatedMarks.percentage,
      updatedMarks.status,
      updatedMarks.remarks,
      updatedMarks.updatedBy,
      updatedMarks.updatedAt,
      marksId
    );
    
    return this.getMarksById(marksId);
  }

  verifyMarks(marksId, verifiedBy) {
    const stmt = db.prepare(`
      UPDATE marks SET
        verifiedBy = ?, verifiedAt = ?
      WHERE id = ?
    `);
    
    stmt.run(verifiedBy, new Date().toISOString(), marksId);
    return this.getMarksById(marksId);
  }

  deleteMarks(marksId) {
    const stmt = db.prepare('DELETE FROM marks WHERE id = ?');
    const result = stmt.run(marksId);
    return result.changes > 0;
  }

  // ==================== GRADE CONFIG METHODS ====================

  addGradeConfig(config) {
    const stmt = db.prepare(`
      INSERT INTO grade_config (
        id, schoolId, name, isDefault, grades, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(
      config.id,
      config.schoolId,
      config.name,
      config.isDefault ? 1 : 0,
      config.grades,
      config.createdAt,
      config.updatedAt
    );
    
    return config;
  }

  getGradeConfigs(schoolId) {
    const stmt = db.prepare('SELECT * FROM grade_config WHERE schoolId = ?');
    return stmt.all(schoolId);
  }

  getDefaultGradeConfig(schoolId) {
    const stmt = db.prepare('SELECT * FROM grade_config WHERE schoolId = ? AND isDefault = 1');
    return stmt.get(schoolId);
  }

  updateGradeConfig(configId, updates) {
    const config = db.prepare('SELECT * FROM grade_config WHERE id = ?').get(configId);
    if (!config) return null;

    const updatedConfig = { ...config, ...updates, updatedAt: new Date().toISOString() };
    
    const stmt = db.prepare(`
      UPDATE grade_config SET
        name = ?, isDefault = ?, grades = ?, updatedAt = ?
      WHERE id = ?
    `);
    
    stmt.run(
      updatedConfig.name,
      updatedConfig.isDefault ? 1 : 0,
      updatedConfig.grades,
      updatedConfig.updatedAt,
      configId
    );
    
    return db.prepare('SELECT * FROM grade_config WHERE id = ?').get(configId);
  }

  deleteGradeConfig(configId) {
    const stmt = db.prepare('DELETE FROM grade_config WHERE id = ?');
    const result = stmt.run(configId);
    return result.changes > 0;
  }

  // ==================== EXAM TEMPLATES ====================

  addExamTemplate(template) {
    const stmt = db.prepare(`
      INSERT INTO exam_templates (
        id, schoolId, name, type, description, totalMarks, passingMarks,
        weightage, isActive, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(
      template.id,
      template.schoolId,
      template.name,
      template.type,
      template.description || null,
      template.totalMarks,
      template.passingMarks,
      template.weightage,
      template.isActive !== undefined ? (template.isActive ? 1 : 0) : 1,
      template.createdAt,
      template.updatedAt
    );
    
    return template;
  }

  getExamTemplates(schoolId, filters = {}) {
    let query = 'SELECT * FROM exam_templates WHERE schoolId = ?';
    const params = [schoolId];

    if (filters.isActive !== undefined) {
      query += ' AND isActive = ?';
      params.push(filters.isActive ? 1 : 0);
    }

    if (filters.type) {
      query += ' AND type = ?';
      params.push(filters.type);
    }

    query += ' ORDER BY createdAt DESC';

    const stmt = db.prepare(query);
    return stmt.all(...params).map(t => ({
      ...t,
      isActive: t.isActive === 1
    }));
  }

  getExamTemplateById(templateId) {
    const stmt = db.prepare('SELECT * FROM exam_templates WHERE id = ?');
    const template = stmt.get(templateId);
    if (template) {
      template.isActive = template.isActive === 1;
    }
    return template;
  }

  updateExamTemplate(templateId, updates) {
    console.log('ðŸ’¾ DataStore updateExamTemplate:', { templateId, updates });
    
    const template = this.getExamTemplateById(templateId);
    if (!template) {
      console.log('âŒ Template not found in dataStore:', templateId);
      return null;
    }

    console.log('ðŸ“‹ Template before update:', template);

    const updatedTemplate = { 
      ...template, 
      ...updates, 
      updatedAt: new Date().toISOString() 
    };

    console.log('ðŸ“ Template after merge:', updatedTemplate);

    const stmt = db.prepare(`
      UPDATE exam_templates SET
        name = ?, type = ?, description = ?, totalMarks = ?, passingMarks = ?,
        weightage = ?, orderSequence = ?, isActive = ?, updatedAt = ?
      WHERE id = ?
    `);

    const result = stmt.run(
      updatedTemplate.name,
      updatedTemplate.type,
      updatedTemplate.description,
      updatedTemplate.totalMarks,
      updatedTemplate.passingMarks,
      updatedTemplate.weightage,
      updatedTemplate.orderSequence,
      updatedTemplate.isActive ? 1 : 0,
      updatedTemplate.updatedAt,
      templateId
    );

    console.log('ðŸ’¾ SQL UPDATE result:', { changes: result.changes, lastInsertRowid: result.lastInsertRowid });

    const finalTemplate = this.getExamTemplateById(templateId);
    console.log('âœ… Template after SQL update:', finalTemplate);

    return finalTemplate;
  }

  deleteExamTemplate(templateId) {
    const stmt = db.prepare('DELETE FROM exam_templates WHERE id = ?');
    const result = stmt.run(templateId);
    return result.changes > 0;
  }

  toggleExamTemplateStatus(templateId) {
    const template = this.getExamTemplateById(templateId);
    if (!template) return null;

    const newStatus = !template.isActive;
    const stmt = db.prepare(`
      UPDATE exam_templates SET isActive = ?, updatedAt = ? WHERE id = ?
    `);
    
    stmt.run(newStatus ? 1 : 0, new Date().toISOString(), templateId);
    return this.getExamTemplateById(templateId);
  }

  // Check if template is used in any periods
  isTemplateUsed(templateId) {
    const stmt = db.prepare('SELECT COUNT(*) as count FROM exam_periods WHERE templateId = ?');
    const result = stmt.get(templateId);
    return result.count > 0;
  }

  // ==================== EXAM PERIODS ====================

  addExamPeriod(period) {
    const stmt = db.prepare(`
      INSERT INTO exam_periods (
        id, schoolId, templateId, academicYear, startDate, endDate,
        status, createdBy, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(
      period.id,
      period.schoolId,
      period.templateId,
      period.academicYear,
      period.startDate,
      period.endDate,
      period.status || 'scheduled',
      period.createdBy,
      period.createdAt,
      period.updatedAt
    );
    
    return period;
  }

  getExamPeriods(schoolId, filters = {}) {
    let query = 'SELECT * FROM exam_periods WHERE schoolId = ?';
    const params = [schoolId];

    if (filters.academicYear) {
      query += ' AND academicYear = ?';
      params.push(filters.academicYear);
    }

    if (filters.templateId) {
      query += ' AND templateId = ?';
      params.push(filters.templateId);
    }

    if (filters.status) {
      query += ' AND status = ?';
      params.push(filters.status);
    }

    query += ' ORDER BY startDate DESC';

    const stmt = db.prepare(query);
    return stmt.all(...params);
  }

  getExamPeriodById(periodId) {
    const stmt = db.prepare('SELECT * FROM exam_periods WHERE id = ?');
    return stmt.get(periodId);
  }

  updateExamPeriod(periodId, updates) {
    const period = this.getExamPeriodById(periodId);
    if (!period) return null;

    const updatedPeriod = { 
      ...period, 
      ...updates, 
      updatedAt: new Date().toISOString() 
    };

    const stmt = db.prepare(`
      UPDATE exam_periods SET
        startDate = ?, endDate = ?, status = ?, updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updatedPeriod.startDate,
      updatedPeriod.endDate,
      updatedPeriod.status,
      updatedPeriod.updatedAt,
      periodId
    );

    return this.getExamPeriodById(periodId);
  }

  deleteExamPeriod(periodId) {
    const stmt = db.prepare('DELETE FROM exam_periods WHERE id = ?');
    const result = stmt.run(periodId);
    return result.changes > 0;
  }

  // Check if period has any exams
  isPeriodUsed(periodId) {
    const stmt = db.prepare('SELECT COUNT(*) as count FROM exams WHERE periodId = ?');
    const result = stmt.get(periodId);
    return result.count > 0;
  }

  // Get exams count for a period
  getExamsCountByPeriod(periodId) {
    const stmt = db.prepare('SELECT COUNT(*) as count FROM exams WHERE periodId = ?');
    const result = stmt.get(periodId);
    return result.count;
  }

  // Get exams by period
  getExamsByPeriod(periodId) {
    const stmt = db.prepare('SELECT * FROM exams WHERE periodId = ? ORDER BY classId, subjectId');
    return stmt.all(periodId);
  }

  // Check if exam exists for period, class, and subject
  getExamByPeriodClassSubject(periodId, classId, subjectId) {
    const stmt = db.prepare(`
      SELECT * FROM exams 
      WHERE periodId = ? AND classId = ? AND subjectId = ?
    `);
    return stmt.get(periodId, classId, subjectId);
  }

  // ==================== BEHAVIOR METHODS ====================

  addBehavior(behavior) {
    const stmt = db.prepare(`
      INSERT INTO behavior (
        id, studentId, teacherId, date, behaviorType, severity, category,
        description, actionTaken, followUpRequired, followUpDate, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(
      behavior.id,
      behavior.studentId,
      behavior.teacherId,
      behavior.date,
      behavior.behaviorType,
      behavior.severity,
      behavior.category,
      behavior.description,
      behavior.actionTaken || null,
      behavior.followUpRequired ? 1 : 0,
      behavior.followUpDate || null,
      behavior.createdAt,
      behavior.updatedAt
    );
    
    return behavior;
  }

  getBehaviors(filters = {}) {
    let query = 'SELECT * FROM behavior WHERE 1=1';
    const params = [];

    if (filters.studentId) {
      query += ' AND studentId = ?';
      params.push(filters.studentId);
    }

    if (filters.teacherId) {
      query += ' AND teacherId = ?';
      params.push(filters.teacherId);
    }

    if (filters.behaviorType) {
      query += ' AND behaviorType = ?';
      params.push(filters.behaviorType);
    }

    if (filters.severity) {
      query += ' AND severity = ?';
      params.push(filters.severity);
    }

    if (filters.startDate) {
      query += ' AND date >= ?';
      params.push(filters.startDate);
    }

    if (filters.endDate) {
      query += ' AND date <= ?';
      params.push(filters.endDate);
    }

    query += ' ORDER BY date DESC, createdAt DESC';

    const stmt = db.prepare(query);
    return stmt.all(...params).map(b => ({
      ...b,
      followUpRequired: b.followUpRequired === 1
    }));
  }

  getBehaviorById(behaviorId) {
    const stmt = db.prepare('SELECT * FROM behavior WHERE id = ?');
    const behavior = stmt.get(behaviorId);
    if (behavior) {
      behavior.followUpRequired = behavior.followUpRequired === 1;
    }
    return behavior;
  }

  getBehaviorsByStudent(studentId, filters = {}) {
    return this.getBehaviors({ ...filters, studentId });
  }

  updateBehavior(behaviorId, updates) {
    const behavior = this.getBehaviorById(behaviorId);
    if (!behavior) return null;

    const updatedBehavior = { 
      ...behavior, 
      ...updates, 
      updatedAt: new Date().toISOString() 
    };

    const stmt = db.prepare(`
      UPDATE behavior SET
        date = ?, behaviorType = ?, severity = ?, category = ?,
        description = ?, actionTaken = ?, followUpRequired = ?, 
        followUpDate = ?, updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updatedBehavior.date,
      updatedBehavior.behaviorType,
      updatedBehavior.severity,
      updatedBehavior.category,
      updatedBehavior.description,
      updatedBehavior.actionTaken,
      updatedBehavior.followUpRequired ? 1 : 0,
      updatedBehavior.followUpDate,
      updatedBehavior.updatedAt,
      behaviorId
    );

    return this.getBehaviorById(behaviorId);
  }

  deleteBehavior(behaviorId) {
    const stmt = db.prepare('DELETE FROM behavior WHERE id = ?');
    const result = stmt.run(behaviorId);
    return result.changes > 0;
  }

  // Faculty Invite operations
  addFacultyInvite(invite) {
    const stmt = db.prepare(`
      INSERT INTO faculty_invites (id, senderId, recipientId, schoolId, status, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      invite.id,
      invite.senderId,
      invite.recipientId,
      invite.schoolId,
      invite.status,
      invite.createdAt,
      invite.updatedAt
    );
    return invite;
  }

  getFacultyInvites() {
    const stmt = db.prepare('SELECT * FROM faculty_invites');
    return stmt.all();
  }

  getFacultyInvitesBySchool(schoolId) {
    const stmt = db.prepare('SELECT * FROM faculty_invites WHERE schoolId = ?');
    return stmt.all(schoolId);
  }

  updateFacultyInvite(inviteId, updates) {
    const stmt = db.prepare(`
      UPDATE faculty_invites 
      SET status = ?, updatedAt = ?
      WHERE id = ?
    `);
    stmt.run(updates.status, updates.updatedAt, inviteId);
    return stmt.all('SELECT * FROM faculty_invites WHERE id = ?')[0];
  }

  deleteFacultyInvite(inviteId) {
    const stmt = db.prepare('DELETE FROM faculty_invites WHERE id = ?');
    const result = stmt.run(inviteId);
    return result.changes > 0;
  }
}

export default new SQLiteStore();
