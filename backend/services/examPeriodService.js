// Exam Period Service - Business logic for exam periods and auto-generation

import dataStore from '../storage/dataStore.js';
import { generateId } from '../utils/helpers.js';

/**
 * Create a new exam period
 */
export async function createPeriod(periodData, userId, autoGenerate = true) {
  // Validation
  if (!periodData.templateId || !periodData.academicYear || 
      !periodData.startDate || !periodData.endDate) {
    throw new Error('Template, academic year, start date, and end date are required');
  }

  // Verify template exists
  const template = dataStore.getExamTemplateById(periodData.templateId);
  if (!template) {
    throw new Error('Template not found');
  }

  if (!template.isActive) {
    throw new Error('Cannot create period with inactive template');
  }

  // Validate dates
  const startDate = new Date(periodData.startDate);
  const endDate = new Date(periodData.endDate);

  if (startDate >= endDate) {
    throw new Error('End date must be after start date');
  }

  // Check for overlapping periods with same template
  const existingPeriods = dataStore.getExamPeriods(periodData.schoolId, {
    templateId: periodData.templateId,
    academicYear: periodData.academicYear
  });

  for (const existing of existingPeriods) {
    const existingStart = new Date(existing.startDate);
    const existingEnd = new Date(existing.endDate);

    if ((startDate >= existingStart && startDate <= existingEnd) ||
        (endDate >= existingStart && endDate <= existingEnd) ||
        (startDate <= existingStart && endDate >= existingEnd)) {
      throw new Error('Period dates overlap with existing period for this template');
    }
  }

  const period = {
    id: generateId(),
    schoolId: periodData.schoolId,
    templateId: periodData.templateId,
    academicYear: periodData.academicYear,
    startDate: periodData.startDate,
    endDate: periodData.endDate,
    status: periodData.status || 'scheduled',
    createdBy: userId,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };

  dataStore.addExamPeriod(period);

  // Auto-generate exams if requested
  let generatedExams = [];
  if (autoGenerate) {
    generatedExams = await autoGenerateExams(period.id, userId);
  }

  return {
    period,
    generatedExamsCount: generatedExams.length,
    generatedExams
  };
}

/**
 * Auto-generate exams for all subjects in all classes
 * This is the KEY function for the standardized exam system
 */
export async function autoGenerateExams(periodId, userId) {
  const period = dataStore.getExamPeriodById(periodId);
  if (!period) {
    throw new Error('Period not found');
  }

  const template = dataStore.getExamTemplateById(period.templateId);
  if (!template) {
    throw new Error('Template not found');
  }

  // Get all classes in the school
  const classes = dataStore.getClassesBySchool(period.schoolId);
  if (classes.length === 0) {
    console.log('⚠️  No classes found in school');
    return [];
  }

  const generatedExams = [];
  const skippedExams = [];

  for (const classData of classes) {
    // Get all subjects for this class
    const subjects = dataStore.getSubjectsByClass(classData.id);
    
    if (subjects.length === 0) {
      console.log(`⚠️  No subjects found for class: ${classData.name}`);
      continue;
    }

    for (const subject of subjects) {
      // Check if exam already exists for this period, class, and subject
      const existing = dataStore.getExamByPeriodClassSubject(
        periodId,
        classData.id,
        subject.id
      );

      if (existing) {
        skippedExams.push({
          classId: classData.id,
          className: classData.name,
          subjectId: subject.id,
          subjectName: subject.name,
          reason: 'Already exists'
        });
        continue;
      }

      // Create exam
      const exam = {
        id: generateId(),
        schoolId: period.schoolId,
        periodId: period.id,
        templateId: template.id,
        classId: classData.id,
        subjectId: subject.id,
        name: `${subject.name} - ${template.name}`,
        type: template.type,
        totalMarks: template.totalMarks,
        passingMarks: template.passingMarks,
        weightage: template.weightage,
        examDate: period.startDate, // Default to period start date
        duration: null,
        instructions: null,
        syllabusTopics: null,
        status: 'scheduled',
        isAutoGenerated: true,
        createdBy: userId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      dataStore.addExam(exam);
      generatedExams.push({
        examId: exam.id,
        className: classData.name,
        subjectName: subject.name,
        examName: exam.name
      });
    }
  }

  console.log(`✅ Generated ${generatedExams.length} exams for period: ${template.name}`);
  if (skippedExams.length > 0) {
    console.log(`⚠️  Skipped ${skippedExams.length} exams (already exist)`);
  }

  return generatedExams;
}

/**
 * Get all periods for a school
 */
export function getPeriods(schoolId, filters = {}) {
  return dataStore.getExamPeriods(schoolId, filters);
}

/**
 * Get period by ID with details
 */
export function getPeriodById(periodId) {
  const period = dataStore.getExamPeriodById(periodId);
  if (!period) {
    throw new Error('Period not found');
  }

  // Get template details
  const template = dataStore.getExamTemplateById(period.templateId);
  
  // Get exams count
  const examsCount = dataStore.getExamsCountByPeriod(periodId);

  return {
    ...period,
    template,
    examsCount
  };
}

/**
 * Update exam period
 */
export async function updatePeriod(periodId, updates, userId) {
  const existingPeriod = dataStore.getExamPeriodById(periodId);
  if (!existingPeriod) {
    throw new Error('Period not found');
  }

  // Validate dates if provided
  if (updates.startDate || updates.endDate) {
    const startDate = new Date(updates.startDate || existingPeriod.startDate);
    const endDate = new Date(updates.endDate || existingPeriod.endDate);

    if (startDate >= endDate) {
      throw new Error('End date must be after start date');
    }
  }

  const updatedPeriod = dataStore.updateExamPeriod(periodId, updates);
  return updatedPeriod;
}

/**
 * Delete exam period
 */
export async function deletePeriod(periodId, userId) {
  const period = dataStore.getExamPeriodById(periodId);
  if (!period) {
    throw new Error('Period not found');
  }

  // Check if period has any exams
  const isUsed = dataStore.isPeriodUsed(periodId);
  if (isUsed) {
    throw new Error('Cannot delete period that has exams. Delete exams first.');
  }

  const deleted = dataStore.deleteExamPeriod(periodId);
  if (!deleted) {
    throw new Error('Failed to delete period');
  }

  return { success: true, message: 'Period deleted successfully' };
}

/**
 * Get exams for a period
 */
export function getExamsByPeriod(periodId) {
  const period = dataStore.getExamPeriodById(periodId);
  if (!period) {
    throw new Error('Period not found');
  }

  const exams = dataStore.getExamsByPeriod(periodId);

  // Enrich with class and subject names
  return exams.map(exam => {
    const classData = dataStore.getClassById(exam.classId);
    const subject = dataStore.getSubjectById(exam.subjectId);

    return {
      ...exam,
      className: classData ? classData.name : 'Unknown',
      subjectName: subject ? subject.name : 'Unknown'
    };
  });
}

/**
 * Get period statistics
 */
export function getPeriodStatistics(periodId) {
  const period = dataStore.getExamPeriodById(periodId);
  if (!period) {
    throw new Error('Period not found');
  }

  const exams = dataStore.getExamsByPeriod(periodId);
  const totalExams = exams.length;

  let marksEntered = 0;
  let totalStudents = 0;

  exams.forEach(exam => {
    const marks = dataStore.getMarksByExam(exam.id);
    const students = dataStore.getStudentsByClass(exam.classId);
    marksEntered += marks.length;
    totalStudents += students.length;
  });

  return {
    periodId,
    totalExams,
    marksEntered,
    totalStudents,
    completionPercentage: totalStudents > 0 ? (marksEntered / totalStudents) * 100 : 0
  };
}

/**
 * Update period status based on dates
 */
export function updatePeriodStatusByDate() {
  const today = new Date().toISOString().split('T')[0];

  // This would be called by a cron job or scheduler
  // For now, it's a manual function that can be called

  // Get all schools
  const schools = dataStore.getSchools();

  schools.forEach(school => {
    const periods = dataStore.getExamPeriods(school.id);

    periods.forEach(period => {
      let newStatus = period.status;

      if (today < period.startDate) {
        newStatus = 'scheduled';
      } else if (today >= period.startDate && today <= period.endDate) {
        newStatus = 'ongoing';
      } else if (today > period.endDate) {
        newStatus = 'completed';
      }

      if (newStatus !== period.status) {
        dataStore.updateExamPeriod(period.id, { status: newStatus });
        console.log(`Updated period ${period.id} status to: ${newStatus}`);
      }
    });
  });
}

/**
 * Validate period data
 */
export function validatePeriodData(data) {
  const errors = [];

  if (!data.templateId) {
    errors.push('Template is required');
  }

  if (!data.academicYear) {
    errors.push('Academic year is required');
  }

  if (!data.startDate) {
    errors.push('Start date is required');
  }

  if (!data.endDate) {
    errors.push('End date is required');
  }

  if (data.startDate && data.endDate) {
    const startDate = new Date(data.startDate);
    const endDate = new Date(data.endDate);

    if (startDate >= endDate) {
      errors.push('End date must be after start date');
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}
